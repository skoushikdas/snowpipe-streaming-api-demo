import unittest
from unittest.mock import patch, MagicMock
from py4j.java_gateway import JavaGateway
from ingestion.session.spark.session_singleton import SparkSessionSingleton
from your_module import JavaAdapter  # Import your class

class Test(unittest.TestCase):

    @patch.object(SparkSessionSingleton, 'get_spark_session')
    @patch('py4j.java_gateway.java_import')
    def test_java_adapter_initialization(self, mock_java_import, mock_get_spark_session):
        # Mock SparkSession and JVM
        mock_spark_session = MagicMock()
        mock_get_spark_session.return_value = mock_spark_session
        mock_spark_session.jvm = MagicMock(spec=JavaGateway)

        # Mock the Java class import
        mock_java_class_path = "com.example.JavaClass"
        mock_java_import.return_value = None

        # Initialize the JavaAdapter
        adapter = JavaAdapter(mock_java_class_path)

        # Test if the Spark session was retrieved from the singleton
        mock_get_spark_session.assert_called_once()

        # Test if the JVM was correctly accessed
        mock_spark_session.jvm.java_import.assert_called_once_with(mock_spark_session.jvm, mock_java_class_path)

        # Test if the Java class was accessed correctly
        mock_spark_session.jvm.getattr.assert_called_once_with(mock_spark_session.jvm, mock_java_class_path)

    @patch.object(SparkSessionSingleton, 'get_spark_session')
    def test_invoke_method_success(self, mock_get_spark_session):
        # Mock SparkSession and Java class
        mock_spark_session = MagicMock()
        mock_get_spark_session.return_value = mock_spark_session
        mock_java_class = MagicMock()
        mock_spark_session.jvm.getattr.return_value = mock_java_class
        mock_method = MagicMock(return_value="Success")
        mock_java_class.some_method = mock_method

        # Initialize the JavaAdapter
        adapter = JavaAdapter("com.example.JavaClass")

        # Invoke the method
        result = adapter.invoke_method("some_method", "arg1", "arg2")

        # Assert that the method was called correctly
        mock_method.assert_called_once_with("arg1", "arg2")
        self.assertEqual(result, "Success")

    @patch.object(SparkSessionSingleton, 'get_spark_session')
    def test_invoke_method_error_handling(self, mock_get_spark_session):
        # Mock SparkSession and Java class
        mock_spark_session = MagicMock()
        mock_get_spark_session.return_value = mock_spark_session
        mock_java_class = MagicMock()
        mock_spark_session.jvm.getattr.return_value = mock_java_class
        mock_method = MagicMock(side_effect=Exception("Java method failed"))
        mock_java_class.some_method = mock_method

        # Initialize the JavaAdapter
        adapter = JavaAdapter("com.example.JavaClass")

        # Invoke the method and assert error handling
        with self.assertRaises(Exception):
            adapter.invoke_method("some_method", "arg1", "arg2")

        # Test that the error was logged
        mock_method.assert_called_once_with("arg1", "arg2")
        mock_spark_session.jvm.logger.error.assert_called_with("Error invoking Java method some_method: Java method failed")

if __name__ == "__main__":
    unittest.main()
